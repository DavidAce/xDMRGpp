#pragma once
#include "expectation_value.h"
#include "math/eig.h"
#include "math/float.h"
#include "math/linalg/matrix/to_string.h"
#include "math/num.h"
#include "math/tenx.h"
#include "opdm.h"
#include "qm/spin.h"
#include "tensors/state/StateFinite.h"
#include "tools/common/log.h"

using tools::finite::measure::RealScalar;

template<typename Scalar>
Eigen::Tensor<Scalar, 2> tools::finite::measure::opdm(const StateFinite<Scalar> &state, ModelType modelType) {
    switch(modelType) {
        case ModelType::ising_majorana: [[fallthrough]];
        case ModelType::ising_sdual: [[fallthrough]];
        case ModelType::ising_tf_rf: return opdm_general(state);
        case ModelType::xxz: [[fallthrough]];
        case ModelType::lbit: return opdm_u1_sym(state);
        default: throw except::runtime_error("unhandled model type: {}", enum2sv(modelType));
    }
}

template<typename Scalar>
Eigen::Tensor<Scalar, 2> tools::finite::measure::opdm_u1_sym(const StateFinite<Scalar> &state) {
    /* We create a matrix R of the form
     *
     *
     * R(i,j) =  | r++ r+- |
     *           | r-+ r-- |
     *
     * where
     *      r++ = r++(i,j) = ⟨sp(i) sz(i)sz(i+1)...sz(j-1) sm(j)⟩
     *      r+- = r+-(i,j) = ⟨sp(i) sz(i)sz(i+1)...sz(j-1) sp(j)⟩
     *      r-+ = r-+(i,j) = ⟨sm(i) sz(i)sz(i+1)...sz(j-1) sm(j)⟩
     *      r-- = r+-(i,j) = ⟨sm(i) sz(i)sz(i+1)...sz(j-1) sp(j)⟩
     *
     * and sp, sm, sz are the plus, minus and z pauli matrices at some site i.
     * Note that each r is an LxL matrix, so R must be a 2Lx2L matrix.
     * Note also that the signs are "crossed" intentionally: r++ has sp and sm, and so on.
     *
     * Note! This only works on states whose reduced density matrices decompose into diagonal
     * blocks with definite particle number (generated by U(1) symmetric Hamiltonians)
     *
     */
    if(state.measurements.opdm) return state.measurements.opdm.value();
    tools::log->trace("Measuring the U1 one-particle density matrix (OPDM)");
    using RealT      = decltype(std::real(std::declval<Scalar>()));
    using MatrixType = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;
    long L           = state.template get_length<long>();
    auto R           = MatrixType(2 * L, 2 * L);  // Allocate the full rho matrix "R"
    auto rpp         = R.topLeftCorner(L, L);     // One quadrant of R: rho++
    auto rpm         = R.topRightCorner(L, L);    // One quadrant of R: rho+-
    auto rmp         = R.bottomLeftCorner(L, L);  // One quadrant of R: rho-+
    auto rmm         = R.bottomRightCorner(L, L); // One quadrant of R: rho--

    auto &sp = qm::spin::half::tensor::sp;
    auto &sm = qm::spin::half::tensor::sm;
    auto &sz = qm::spin::half::tensor::sz;

    // Shorthand types
    using op_t       = LocalObservableOp<cx64>;
    using opstring_t = std::vector<op_t>;
    for(long pos_i = 0; pos_i < L; ++pos_i) {
        for(long pos_j = pos_i; pos_j < L; ++pos_j) {
            // Create an operator string from pos_i to pos_j, where
            //      pos_i has sp (or sm)
            //      pos_j has sm (or sp)
            // Then insert sz from pos_i (including) to pos_j (excluding).
            auto opp = opstring_t{op_t{sp, pos_i}}; // adds s+_i
            auto opm = opstring_t{op_t{sp, pos_i}}; // adds s+_i
            auto omp = opstring_t{op_t{sm, pos_i}}; // adds s-_i
            auto omm = opstring_t{op_t{sm, pos_i}}; // adds s-_i
            if(pos_i < pos_j) {
                for(auto pos_x : num::range(pos_i, pos_j)) {
                    opp.emplace_back(op_t{sz, pos_x}); // adds sz_i sz_{i} ... sz_{j-1}
                    opm.emplace_back(op_t{sz, pos_x}); // adds sz_i sz_{i} ... sz_{j-1}
                    omp.emplace_back(op_t{sz, pos_x}); // adds sz_i sz_{i} ... sz_{j-1}
                    omm.emplace_back(op_t{sz, pos_x}); // adds sz_i sz_{i} ... sz_{j-1}
                }
            }
            opp.emplace_back(op_t{sm, pos_j}); // adds  s-_j
            opm.emplace_back(op_t{sp, pos_j}); // adds  s+_j
            omp.emplace_back(op_t{sm, pos_j}); // adds  s-_j
            omm.emplace_back(op_t{sp, pos_j}); // adds  s+_j

            // Calculate the expectation value of the operator string
            rpp(pos_i, pos_j) = expectation_value<Scalar>(state, opp);
            rpm(pos_i, pos_j) = expectation_value<Scalar>(state, opm);
            rmp(pos_i, pos_j) = expectation_value<Scalar>(state, omp);
            rmm(pos_i, pos_j) = expectation_value<Scalar>(state, omm);

            // Set the Hermitian conjugates on the opposite side
            if(pos_i != pos_j) {
                if constexpr(sfinae::is_std_complex_v<Scalar>) {
                    rpp(pos_j, pos_i) = std::conj(rpp(pos_i, pos_j));
                    rpm(pos_j, pos_i) = std::conj(rmp(pos_i, pos_j)); // Mix pm <-> mp
                    rmp(pos_j, pos_i) = std::conj(rpm(pos_i, pos_j)); // Mix mp <-> pm
                    rmm(pos_j, pos_i) = std::conj(rmm(pos_i, pos_j));
                } else {
                    rpp(pos_j, pos_i) = rpp(pos_i, pos_j);
                    rpm(pos_j, pos_i) = rmp(pos_i, pos_j); // Mix pm <-> mp
                    rmp(pos_j, pos_i) = rpm(pos_i, pos_j); // Mix mp <-> pm
                    rmm(pos_j, pos_i) = rmm(pos_i, pos_j);
                }
            }
        }
    }
    // tools::log->info("r++: trace {:.16f}\n{}", rpp.trace(), linalg::matrix::to_string(rpp, 8));
    // tools::log->info("r+-: trace {:.16f}\n{}", rpm.trace(), linalg::matrix::to_string(rpm, 8));
    // tools::log->info("r-+: trace {:.16f}\n{}", rmp.trace(), linalg::matrix::to_string(rmp, 8));
    // tools::log->info("r--: trace {:.16f}\n{}", rmm.trace(), linalg::matrix::to_string(rmm, 8));
    // tools::log->debug("R    : trace {:.16f}", R.trace());
    assert(rpp.isApprox(rpp.adjoint(), std::numeric_limits<RealT>::epsilon() * 1000));
    assert(rmm.isApprox(rmm.adjoint(), std::numeric_limits<RealT>::epsilon() * 1000));
    assert(rpm.isApprox(rmp.adjoint(), std::numeric_limits<RealT>::epsilon() * 1000));
    if(not R.isApprox(R.conjugate().transpose())) throw except::logic_error("R is not hermitian");
    if(std::abs(R.trace() - static_cast<RealT>(L)) > RealT{1e-8f}) throw std::runtime_error("R.trace() != L");
    state.measurements.opdm = tenx::TensorMap(R);
    return state.measurements.opdm.value();
}

template<typename Scalar>
Eigen::Tensor<Scalar, 2> tools::finite::measure::opdm_general(const StateFinite<Scalar> &state) {
    /* We create a matrix of the form
     *
     *
     * R(i,j) =  | r++ |
     *
     * where
     *      r++ = r++(i,j) = ⟨sp(i) sz(i)sz(i+1)...sz(j-1) sm(j)⟩
     *
     * and sp, sm, sz are the plus, minus and z pauli matrices at some site i.
     * Note that each r is an LxL matrix, so R must be a 2Lx2L matrix.
     * Note also that the signs are "crossed" intentionally: r++ has sp and sm, and so on.
     *
     */
    if(state.measurements.opdm) return state.measurements.opdm.value();
    tools::log->trace("Measuring the general one-particle density matrix (OPDM)");
    using MatrixType = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;
    using RealT      = decltype(std::real(std::declval<Scalar>()));

    long L   = state.template get_length<long>();
    auto R   = MatrixType(L, L);      // Allocate the full rho matrix "R"
    auto rpp = R.topLeftCorner(L, L); // One quadrant of R: rho++

    auto &sp = qm::spin::half::tensor::sp;
    auto &sm = qm::spin::half::tensor::sm;
    auto &sz = qm::spin::half::tensor::sz;

    // Shorthand types
    using op_t       = LocalObservableOp<cx64>;
    using opstring_t = std::vector<op_t>;
    for(long pos_i = 0; pos_i < L; ++pos_i) {
        for(long pos_j = pos_i; pos_j < L; ++pos_j) {
            // Create an operator string from pos_i to pos_j, where
            //      pos_i has sp (or sm)
            //      pos_j has sm (or sp)
            // Then insert sz from pos_i (including) to pos_j (excluding).
            auto opp = opstring_t{op_t{sp, pos_i}}; // adds s+_i
            if(pos_i < pos_j) {
                for(auto pos_x : num::range(pos_i, pos_j)) {
                    opp.emplace_back(op_t{sz, pos_x}); // adds sz_i sz_{i} ... sz_{j-1}
                }
            }
            opp.emplace_back(op_t{sm, pos_j}); // adds  s-_j

            // Calculate the expectation value of the operator string
            rpp(pos_i, pos_j) = expectation_value<Scalar>(state, opp);

            // Set the Hermitian conjugates on the opposite side
            if(pos_i != pos_j) {
                if constexpr(sfinae::is_std_complex_v<Scalar>) {
                    rpp(pos_j, pos_i) = std::conj(rpp(pos_i, pos_j));
                } else {
                    rpp(pos_j, pos_i) = rpp(pos_i, pos_j);
                }
            }
        }
    }

    assert(rpp.isApprox(rpp.adjoint(), RealT{1e-12f}));
    if(not R.isApprox(R.adjoint())) throw except::logic_error("R is not hermitian");
    state.measurements.opdm = tenx::TensorMap(R);
    return state.measurements.opdm.value();
}

template<typename Scalar>
Eigen::Tensor<RealScalar<Scalar>, 1> tools::finite::measure::opdm_spectrum(const StateFinite<Scalar> &state, ModelType modelType) {
    if(not state.measurements.opdm) state.measurements.opdm = opdm(state, modelType);
    if(not state.measurements.opdm_spectrum) {
        // auto                  &opdm      = state.measurements.opdm.value();
        // auto                   solver    = eig::solver();
        // Eigen::Tensor<cx64, 2> opdm_cx64 = tenx::asScalarType<cx64>(opdm);
        // solver.eig<eig::Form::SYMM>(opdm_cx64.data(), opdm.dimension(0), eig::Vecs::OFF);
        // Eigen::Tensor<fp64, 1> opdm_spectrum_fp64 = tenx::TensorCast(eig::view::get_eigvals<fp64>(solver.result));
        // state.measurements.opdm_spectrum          = tenx::asScalarType<RealScalar<Scalar>>(opdm_spectrum_fp64);
        using RealT  = decltype(std::real(std::declval<Scalar>()));
        auto &opdm   = state.measurements.opdm.value();
        auto  solver = eig::solver();
        solver.eig<eig::Form::SYMM>(opdm.data(), opdm.dimension(0), eig::Vecs::OFF);
        Eigen::Tensor<RealT, 1> opdm_spectrum     = tenx::TensorCast(eig::view::get_eigvals<RealT>(solver.result));
        auto                    opdm_spectrum_vec = tenx::VectorMap(opdm_spectrum);
        RealT                   minEval           = opdm_spectrum_vec.minCoeff();
        RealT                   maxEval           = opdm_spectrum_vec.maxCoeff();
        auto                    eps               = std::numeric_limits<RealT>::epsilon();
        if(maxEval > RealT{1} + 10 * eps or minEval < RealT{0} - 10 * eps)
            tools::log->warn("opdm_spectrum has eigenvalues outside [0,1]: {::.16f}", opdm_spectrum_vec);
        state.measurements.opdm_spectrum = opdm_spectrum;
    }
    return state.measurements.opdm_spectrum.value();
}
